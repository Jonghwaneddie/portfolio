  <!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cabinet (2023)</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/variable/pretendardvariable-dynamic-subset.css">

  <style>
     body {
    font-size: 11px;
    letter-spacing: 0.2px;
  }

        * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Montserrat', sans-serif;
      background: #fff;
      color: #000;
      margin-left: 120px; /* 메뉴 공간 확보 */
      padding: 60px 20px;
    }
/* ✅ 모바일에서만 폰트 크기 줄이기 */
  @media (max-width: 768px) {
    body {
      font-size: 11px;
    }
      .description p {
    letter-spacing: 0.0px;  /* 자간 줄이기 */
    line-height: 30;       /* 행간 늘리기 */
  }

  h1 {
    letter-spacing: 1px;    /* 제목 자간 약간 줄이기 */
    line-height: 1.3;       /* 제목 행간 조절 */
  }

  .caption-container {
    letter-spacing: 0.5px;
    line-height: 1.4;
  }
  }
    

    #menu-container {
      margin-bottom: 30px;
    }

    h1 {
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 1.5px;
      margin-bottom: 20px;
      max-width: 630px;
      width: 100%; /* 70% → 100%로 변경 */
      margin: 0 0 20px 0; /* 중앙정렬 대신 좌측정렬 맞춤 */
    }

    .gallery-container {
      display: flex;
      flex-direction: column;
      align-items: flex-start; /* 가운데 → 왼쪽 정렬 */
    }

    .description {
      max-width: 630px;
      width: 100%; /* 70% → 100% */
      margin: 0 0 20px 0; /* 중앙 정렬 대신 좌측 정렬 */
      text-align: left;
    }

    .description p {
      font-size: 11px;
      font-weight: 300;
      letter-spacing: 1.2px;
      line-height: 1.4;
    }

    .image-list {
      display: flex;
      flex-direction: column;
      gap: 15px;
      max-width: 630px;
      width: 100%; /* 70% → 100% */
      align-items: flex-start;
    }

    .image-list img {
      width: 100%;
      height: auto;
      cursor: pointer;
      border-radius: 4px;
      transition: transform 0.2s;
    }

    .image-list img:hover {
      transform: scale(1.02);
    }

    .caption-container {
      max-width: 630px;
      width: 100%; /* 70% → 100% */
      margin: 15px 0 0 0; /* 중앙 정렬 대신 좌측 정렬 유지 불필요하므로 아래에서 오른쪽 정렬 유지 */
      text-align: right; /* 마지막 캡션 오른쪽 정렬 유지 */
      font-size: 11px;
      font-weight: 300;
      color: #444;
      font-style: italic;
      letter-spacing: 0.8px;
      line-height: 1.3;
    }

    .modal {
      display: none;
      position: fixed;
      z-index: 999;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.8);
      justify-content: center;
      align-items: center;
    }

    .modal img {
      max-width: 90vw;
      max-height: 90vh;
      border-radius: 5px;
      box-shadow: 0 0 20px rgba(0,0,0,0.6);
    }

    .modal-close {
      position: fixed;
      top: 20px;
      right: 30px;
      font-size: 30px;
      color: #fff;
      cursor: pointer;
      user-select: none;
    }
  </style>
</head>
<body>

  <div id="menu-container"></div>

  <h1>Cabinet (2023)</h1>

  <div class="gallery-container">
    <div class="description">
      <p>
       ‘Cabinet’은 단순한 수납 구조가 아니라, 보이지 않는 것을 수집하고 보존하는 장소, 나아가 회화를 기록하는 새로운 방식에 대한 탐색의 장으로 제안된다.
고대의 ‘호기심의 방(Wunderkammer)’이 세계의 단면을 수집하고 배열하며 하나의 인식 구조를 만들어냈듯, 이 전시에서의 캐비닛은 회화를 감각적으로 기록하고 물리적으로 저장하는 장소로 작동한다.
기존의 사진 매체는 회화를 납작한 이미지로 환원시키며, 지지체의 물질성, 화면의 구조, 시간성과 같은 회화의 본질적 요소를 배제한다.
이에 반해, 프로타주는 회화와의 신체적 접촉을 통해 그 표면 너머의 두께, 굴곡, 질감, 잔여 정보 등을 비시각적 감각으로 기록하는 방식으로 기능한다.
이는 회화를 단순한 이미지가 아닌, 기록 가능한 물질이자 접촉 가능한 사건으로 인식하게 하며, 회화와 기록, 이미지와 구조 사이의 간극을 새롭게 사유하게 한다.
        <br>
        <br>
        Cabinet is presented not merely as a structure for storage, but as a space for collecting and preserving what is invisible — a platform for exploring new methods of recording painting.
Just as the historical Wunderkammer (cabinet of curiosities) gathered fragments of the world and organized them into a system of knowledge, the cabinet in this exhibition functions as a site for sensory recording and material archiving of painting.
While traditional photography flattens painting into an image, excluding its material substrate, structural depth, and temporality, frottage offers an alternative approach.
Through physical contact with the surface, frottage captures what lies beyond the visible — the thickness, texture, contours, and residual information of the work.
In this context, painting is no longer approached merely as an image, but as a recordable material and a tactile event, opening a space to reflect on the gaps between painting and documentation, image and structure.
    </div>

    <div class="image-list">
      <img src="cabinetimages/cabinet1.jpg" alt="cabinet 1">
      <img src="cabinetimages/cabinet2.jpg" alt="cabinet 2">
      <img src="cabinetimages/cabinet3.jpg" alt="cabinet 3">
      <img src="cabinetimages/cabinet4.jpg" alt="cabinet 4">
      <img src="cabinetimages/cabinet5.jpg" alt="cabinet 5">
      <img src="cabinetimages/cabinet6.jpg" alt="cabinet 6">
      <img src="cabinetimages/cabinet7.jpg" alt="cabinet 7">
      <img src="cabinetimages/cabinet8.jpg" alt="cabinet 8">
      <img src="cabinetimages/cabinet9.jpg" alt="cabinet 9">
      <img src="cabinetimages/cabinet10.jpg" alt="cabinet 10">
      <img src="cabinetimages/cabinet11.jpg" alt="cabinet 11">
      <img src="cabinetimages/cabinet12.jpg" alt="cabinet 12">
      <img src="cabinetimages/cabinet13.jpg" alt="cabinet 13">
      <img src="cabinetimages/cabinet14.jpg" alt="cabinet 14">
      <img src="cabinetimages/cabinet15.jpg" alt="cabinet 15">
      
    </div>

    <div class="caption-container">
      Photography by SES<br>사진 성의석
    </div>
  </div>

  <div class="modal" id="imageModal">
    <span class="modal-close" id="modalClose">&times;</span>
    <img id="modalImage" src="" alt="확대 이미지" />
  </div>

  <script>
    fetch('menu.html')
      .then(res => res.text())
      .then(html => {
        document.getElementById('menu-container').innerHTML = html;

        window.toggleProjectMenu = function(e, submenuId) {
          e.preventDefault();

          const submenu1 = document.getElementById('projectSubmenu1');
          const submenu2 = document.getElementById('projectSubmenu2');
          const targetSubmenu = document.getElementById(submenuId);
          if (!targetSubmenu) return;

          if (submenuId === 'projectSubmenu1' && submenu2.classList.contains('show')) {
            submenu2.style.maxHeight = null;
            submenu2.classList.remove('show');
          } else if (submenuId === 'projectSubmenu2' && submenu1.classList.contains('show')) {
            submenu1.style.maxHeight = null;
            submenu1.classList.remove('show');
          }

          if (targetSubmenu.classList.contains('show')) {
            targetSubmenu.style.maxHeight = null;
            targetSubmenu.classList.remove('show');
          } else {
            targetSubmenu.style.maxHeight = targetSubmenu.scrollHeight + "px";
            targetSubmenu.classList.add('show');
          }
        };
      });

    const modal = document.getElementById("imageModal");
    const modalImg = document.getElementById("modalImage");
    const closeBtn = document.getElementById("modalClose");

    document.querySelectorAll('.image-list img').forEach((img, index) => {
      img.addEventListener('click', () => {
        modal.style.display = "flex";
        modalImg.src = img.src;
        currentIndex = index;
      });
    });

    closeBtn.addEventListener('click', () => modal.style.display = "none");
    modal.addEventListener('click', e => {
      if (e.target === modal) modal.style.display = "none";
    });
    document.addEventListener('keydown', e => {
      if (e.key === 'Escape') {
        modal.style.display = "none";
      }
      if (modal.style.display === "flex") {
        if (e.key === "ArrowRight") {
          showNextImage();
        }
        if (e.key === "ArrowLeft") {
          showPrevImage();
        }
      }
    });

    let currentIndex = 0;
    const images = document.querySelectorAll('.image-list img');

    function showNextImage() {
      currentIndex = (currentIndex + 1) % images.length;
      modalImg.src = images[currentIndex].src;
    }

    function showPrevImage() {
      currentIndex = (currentIndex - 1 + images.length) % images.length;
      modalImg.src = images[currentIndex].src;
    }
  </script>

</body>
</html>
